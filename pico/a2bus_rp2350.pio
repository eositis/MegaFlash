; Ver 3 - Registers value are prefetched to PIO, support up to 16 registers
; CPU doesn't need to do anything for 6502 read cycle
;
; Ver 3.1 - Try to pull regvalue from FIFO again before outputting data
;
; Ver 4.0 - Complete rewrite for RP2350
;
; The usual implementation is that the PIO program informs the CPU when 6502 
; is reading from us. The CPU then sends the data to PIO program. The PIO program 
; outputs the data to 6502. But the CPU only has 450ns, which equals to 67 cycles
; on RP2350, to process the request. 

; But MegaFlash is just a device at slot 4. It only has 16 I/O registers from $C0C0 
; to $C0CF. The current values of those registers can be stored in PIO state machine 
; memory. The state machine can response 6502 read request without the help from CPU.

; RP2350 provides direct access of RX FIFO registers. There are 4 32-bit FIFO registers.
; Each FIFO register stores 4 6502 8-bit registers. FIFO register 0 is for $C0C0 to $C0C3
; and so on.

; Two state machines are needed. The first one, a2bus_listener, capture all bus access to
; MegaFlash and relay the message to CPU.

; The second one, a2bus, fulfills the read request from 6502. It reads the lowest 4-bit of
; address bus and send the corresponding right to 6502.


; Pin Allocations
;   9-6: Apple Address Bus A3-0
;    10: R/nW
; 18-11: Apple Data Bus D7-D0
;    19: PHI0
;    20: nDEVSEL, Active Low
;    22: nPICOWR, Output, Active Low


.pio_version RP2350

.define public A2BUS_BASE   6   ; Apple Bus at GPIO 06-18
.define public A2DBUS_BASE  11  ; Apple Data Bus at GPIO11-18
.define public A2BUS_WIDTH  13  ; A3-A0 + R/nW + 8-bit Databus
.define public R_NW_GPIO    10  ; R/nW at GPIO 10
.define public PHI0_GPIO    19  ; PHI0 at GPIO 19
.define public nDEVSEL_GPIO 20  ; DEVSEL at GPIO 20, Active Low
.define public nPICOWR_GPIO 22  ; Indicate Pico is outputting data

;/////////////////////////////////////////////////////////////////////
;
; a2buslistener 
;
; This state machine captures any read or write request to Megaflash
; and send the request to CPU
;
;/////////////////////////////////////////////////////////////////////


.program a2buslistener

   
.wrap_target

  wait 0 gpio nDEVSEL_GPIO   ; wait unti nDEVSEL is activated
  jmp PIN,read_cycle
  
  ;
  ;6502 is writing to us
  ;
  nop   [16]            ; Delay awhile before reading data from 6502 bus
                        ; When 6502 is writing to Pico, the data bus 
                        ; is not valid when nDEVSEL is just activated. We need
                        ; to delay awhile to get valid data.
                        ; Test shows that if the delay is 14, it starts to work.
                        ; So, we set to 16 for additional margin.
  
  ;then, same implemntation as read cycle

  ;
  ;6502 is reading from us
  ;
read_cycle:
  mov isr, null   	; Clear ISR. No need to add delay for read cycle. Only address bus is needed 
 
  in pins, A2BUS_WIDTH  ; Read Apple Bus
  push noblock          ; Don't use auto-push since auto-push is blocking
   
  ;
  ;Wait until current cycle ends
  ;	 
  wait 0 gpio PHI0_GPIO  ;Doesn't work without this instruction
                         ;PHI0 should goes low before nDEVSEL goes high
                         ;Don't understand why it doesn't work without 
                         ;this instruction. Don't bother to find out
                         ;with scope.

  ; Wait until nDEVSEL_GPIO is inactive
  ; When the Apple II side is un-powered, both nDEVSEL and PHI0 is low
  ; even the built-in pull-up resistors are enabled.
  ; So, an access to us is continuously triggered.
  ; Adding this instruction prevents that.
  wait 1 gpio nDEVSEL_GPIO

.wrap

;/////////////////////////////////////////////////////////////////////
;
; a2bus 
;
; This state machine fulfill 6502 read requests.
;
;/////////////////////////////////////////////////////////////////////

.program a2bus
.fifo txget
.side_set 1 opt

  mov pindirs, null  side 1     ;Switch pindirs to input
	
.wrap_target
  wait 0 gpio nDEVSEL_GPIO      ; wait unti nDEVSEL is activated

  jmp PIN,read_cycle 
  jmp cycle_end
  
  ;
  ;6502 is reading from us
  ;  
read_cycle:    
  ;For Megaflash, it is preferred to pull the output value from
  ;rxfifo as late as possible to give CPU more time to process
  ;the previous request. So, delay is added to each instruction.
  ;But it causes problem when a 6502 read cycle also trigger 
  ;a change of register values such as Slinky emulation and reading
  ;of parameter/data buffers. The CPU should not update the value 
  ;until PIO has pulled the output value of current cycle.
  ;So, a flag IRQ 0 indicates the PIO is delaying the pull of output
  ;value. CPU should not update the register values until the flag
  ;is cleared.

  irq set 0      [7]            ;To indicate we are delaying the pull of output value
  mov osr, pins  [7]            ;Read Apple Bus
  out x,2        [7]            ;x=A1:A0
  out y,2        [7]            ;y=A3:A2
  nop            [7]            ;Additional delay
  nop            [6]            ;Additional delay

  ;Read output value to osr  
  mov osr,rxfifo[y]    
  irq clear 0                   ;To indicate we have pulled output value from rxfifo

byte_select:                    ;Max loop 4 times
  out pins, 8                   ;Send lowest byte out
  jmp x--,byte_select

  ;Timing: Max 60 cycles or 400ns from nDEVSEL is activted
  mov pindirs,~null  side 0     ;Switch pindirs to output	

cycle_end:
  wait 0 gpio PHI0_GPIO         ;wait until PHI0 goes low
  mov pindirs, null  side 1     ;Switch pindirs to input
  wait 1 gpio nDEVSEL_GPIO      ;See note above
.wrap


% c-sdk {

//
// Set GPIO function to PIO and setup pull resistors
//
static void a2bus_gpio_init(PIO pio) {
  for (int pin=A2BUS_BASE; pin<A2BUS_BASE+A2BUS_WIDTH; ++pin) {
    pio_gpio_init(pio, pin);
    gpio_pull_down(pin);    //Enable Pull down resistor, to avoid floating of LVC4245 inputs
  }
  
  //GPIO: Configure PHI0, nDEVSEL and nPICOWR
  pio_gpio_init(pio,nDEVSEL_GPIO);
  gpio_pull_down(nDEVSEL_GPIO);
  pio_gpio_init(pio,PHI0_GPIO);
  gpio_pull_down(PHI0_GPIO);  
  pio_gpio_init(pio,nPICOWR_GPIO);
}

//
// Initalize a2buslistner
//
static void a2buslistener_program_init(PIO pio,uint sm,uint offset) {
  //setup wrap target and return the state machine config struct
  pio_sm_config c = a2buslistener_program_get_default_config(offset);

  //IN instruction PINS mapping
  sm_config_set_in_pins(&c, A2BUS_BASE);

  //shift_right: false (data go to LSB)
  //autopush: false
  //push_threashold: 0
  sm_config_set_in_shift(&c, false, false, 0);
	
  //JMP instruction PIN mapping
  sm_config_set_jmp_pin(&c, R_NW_GPIO); 	
  
  //GPIO: Address Bus, RnW, Data bus as input
  pio_sm_set_consecutive_pindirs(pio, sm, A2BUS_BASE, A2BUS_WIDTH, false /*=in*/); 

  //Load configuration to State Machine and
  //setup Program Counter
  pio_sm_init(pio, sm, offset, &c);
}

//
// Initalize a2bus
//
static void a2bus_program_init(PIO pio,uint sm,uint offset) {
  //setup wrap target and return the state machine config struct
  pio_sm_config c = a2bus_program_get_default_config(offset);

  //IN instruction PINS mapping
  sm_config_set_in_pins(&c, A2BUS_BASE);

  //OUT instruction PINS and PINDIRS mapping
  sm_config_set_out_pins(&c, A2DBUS_BASE, 8);
  
  //Sideset PIN mapping
  sm_config_set_sideset_pins(&c, nPICOWR_GPIO);  

  //JMP instruction PIN mapping
  sm_config_set_jmp_pin(&c, R_NW_GPIO); 

  //shift_right: false (data go to LSB)
  //autopush: false
  //push_threashold: 0
  sm_config_set_in_shift(&c, false, false, 0);
  
  //shift_right: true
  //autopull: false
  //pull_threshold: 0
  sm_config_set_out_shift(&c, true, false, 0);

  //GPIO: Address Bus, RnW, Data bus as input
  pio_sm_set_consecutive_pindirs(pio, sm, A2BUS_BASE, A2BUS_WIDTH, false /*=in*/); 

  //GPIO:PICOWR pin as output
  pio_sm_set_consecutive_pindirs(pio, sm, nPICOWR_GPIO, 1, true /*=out*/);
  
  //Make sure IRQ 0 is cleared
  pio_interrupt_clear(pio, 0);
  
  //Load configuration to State Machine and
  //setup Program Counter
  pio_sm_init(pio, sm, offset, &c);
}

%}

