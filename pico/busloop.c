#include <stdio.h>
#include <string.h>
#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "a2bus.h"
#include "defines.h"
#include "busloop.h"
#include "cmdhandler.h"
#include "dmamemops.h"

//--------------------------------------------------------------------
//Accessing buffers from Apple IIc
//The parameter buffer and data buffer can be accessed from address
//$C0C1 and $C0C2. There are internal address pointers in MegaFlash.
//When those addresses is accessed, the pointers advance by one
//automatically. When end of buffer is reached, the pointer loop around
//to the begining of the buffer.
//
//Interleaved Mode
//================
//The data buffer is mainly for storing ProDOS data block. The block is 512 bytes
//long, which is two 6502 pages.To access the buffer, read/write loop
//has to be executed twice.
//
//To reduce the loop overhead, interleaved mode is provided for Data Buffer.
//In this mode, the buffer is divided into two parts, $00-$FF and $100-$1FF.
//When the lower part is accessed, the pointer jumps to the same offset of
//of upper part. When the upper part is accessed, it jumps to next offset of
//lower part.
//
//i.e. The sequence of the pointer is
//
// $0 -> $100 -> $1 -> $101 -> $2 ->$102 -> ... -> $FF ->$1FF -> $0
//
//With interleaved mode, there are two memory accesses in each loop iteration and
//loop overhead can be reduced.
//
//This sequence can be generated by this expression:
//  (dataBufferIndex&0x100)?(dataBufferIndex+1)&0xff:dataBufferIndex|0x100;
//
//Important:
// Switching to interleaved mode should be temporary. The mode should be restored
// to linear after data transfer.
//-----

//--------------------------------------------------------------
//The definitions below must be the same as the ones in a2bus.c
extern union {
  uint8_t  r[16];     //Individual 8-bit registers
  uint32_t i32[4];    //Chunks of 4 32-bit registers
} registers;
//---------------------------------------------------------------------


//---------------------------------------------------------------------
// Parameter / Data Buffers
uint parameterBufferIndex;
uint dataBufferIndex;
uint8_t __attribute__((aligned(4))) parameterBuffer[PARAMBUFFERSIZE]; 
uint8_t __attribute__((aligned(4))) dataBuffer[DATABUFFERSIZE];
transfermode_t dataBufferTransferMode;  //Linear or Interleaved mode
//---------------------------------------------------------------------



//This function is called when switching mode from Slinky to MegaFlash.
//We want the switching to be as fast as possible. 
//So, don't remove __no_inline_not_in_flash_func
void __no_inline_not_in_flash_func(BusLoopDataInit)() {
  //Clear parameterBuffer by CPU.
  //ParameterBuffer is small, not worth using DMA.
  memset(parameterBuffer, 0, PARAMBUFFERSIZE);
  
  parameterBufferIndex = 0;
  dataBufferIndex = 0;
  dataBufferTransferMode = DEFAULTTRANSFERMODE;

  registers.r[IDREG] = IDREG_VAL;
  registers.r[STATUSREG]=0;
  registers.r[PARAMREG]=parameterBuffer[0];
  registers.r[DATAREG]=dataBuffer[0];
  registers.i32[1] = 0;
  registers.i32[2] = 0;  
  registers.i32[3] = 0; 
  
  //Send MegaFlash Registers to PIO
  UpdateMegaFlashRegisters(0,registers.i32[0]);
  UpdateMegaFlashRegisters(1,registers.i32[1]);
  UpdateMegaFlashRegisters(2,registers.i32[2]);  
  UpdateMegaFlashRegisters(3,registers.i32[3]);
}

void __no_inline_not_in_flash_func(BusLoop)() {
  const uint SM0 = 0;   //State Machine 0 for $C0C0-$C0C3 registers 
  const uint READFLAG = (1<<4); //Read flag is at bit 4

  while(true) {
    //8-bit data from Apple + RnW Flag + 4-bit address from Apple
    uint32_t busdata = GetAppleBusBlocking();
    uint32_t addr = busdata & 0b1111;     //Lower nibble of Apple Address

    if (busdata & READFLAG) {
      //6502 is reading from us
      switch(addr) {
        case DATAREG:
          //advance dataBufferIndex
          if (dataBufferTransferMode==MODE_LINEAR) dataBufferIndex = (dataBufferIndex + 1) & DATABUFFERINDEXMASK; //loop around if end of buffer is reached
          else dataBufferIndex = (dataBufferIndex&0x100)?(dataBufferIndex+1)&0xff:dataBufferIndex|0x100;
          
          registers.r[DATAREG] = dataBuffer[dataBufferIndex];
          break;
        case PARAMREG:
          parameterBufferIndex = (parameterBufferIndex + 1) & PARAMBUFFERINDEXMASK; //loop around if end of buffer is reached
          registers.r[PARAMREG] = parameterBuffer[parameterBufferIndex];
          break;        
        case IDREG: 
          registers.r[IDREG] = ~registers.r[IDREG];  //Bitwise NOT
          break;          
        default:
          continue; //No need to update MegaFlash Registers if reading other addresses
      }
      
    } else {
        //6502 is writing to us
        uint32_t data = (busdata >>5) & 0xff; //8-bit data from Apple
        
        switch(addr) {
          case CMDREG:
            //Set Busy Flag
            registers.r[STATUSREG] |= BUSYFLAG;
            
            //Send Busy Flag to PIO State Machine
            UpdateMegaFlashRegisters(0, registers.i32[0]);

            //Execute the command
            DoCommand(data);
            
            //Clear Busy Flag
            registers.r[STATUSREG] &= ~BUSYFLAG;
            break;
          case DATAREG:
            dataBuffer[dataBufferIndex] = data;
            
            //advance dataBufferIndex
            if (dataBufferTransferMode==MODE_LINEAR) dataBufferIndex = (dataBufferIndex + 1) & DATABUFFERINDEXMASK; //loop around if end of buffer is reached
            else dataBufferIndex = (dataBufferIndex&0x100)?(dataBufferIndex+1)&0xff:dataBufferIndex|0x100;
            
            registers.r[DATAREG] = dataBuffer[dataBufferIndex];
            break;
          case PARAMREG:
            parameterBuffer[parameterBufferIndex] = data;
            parameterBufferIndex = (parameterBufferIndex + 1) & PARAMBUFFERINDEXMASK;
            registers.r[PARAMREG] = parameterBuffer[parameterBufferIndex];
            break;      
          case IDREG:
            break;    //Do nothing. IDREG is not writable.
          default:
            //$C0C4-$C0CF behave like RAM
            registers.r[addr]=data;
            break;
      } 
    } 
    
#ifndef PICO_RP2040    
    //see note in slinky.c
    if (pio_sm_is_rx_fifo_empty(pio0, SM_LISTENER)) {
      while(pio_interrupt_get(pio0,0 /*= irq 0*/)) {
        tight_loop_contents(); //Wait until irq 0 is cleared
      }
    }
#endif    
    //Update MegaFlash registers
    UpdateMegaFlashRegisters(0,registers.i32[0]);
    UpdateMegaFlashRegisters(1,registers.i32[1]);
    UpdateMegaFlashRegisters(2,registers.i32[2]);
    UpdateMegaFlashRegisters(3,registers.i32[3]);    
  }//while  
}



